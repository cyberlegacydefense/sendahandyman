<script>
    // ============================================================================
    // CONSTANTS & CONFIGURATION
    // ============================================================================
    const APP_VERSION = "2.0.7";
    const STRIPE_PUBLISHABLE_KEY = 'pk_test_51Rz41zHQ4TkcNcqvEebLo8rN5MmgInckOQSG6tuZa4XoN6czEXbxK8FtXcJqEu9RbkHclHxRhXRHVRAxDJ2q6PtD00KbGASb91';
    const ZAPIER_CONFIG = {
        WEBHOOK_URL: 'https://hooks.zapier.com/hooks/catch/24412806/uh8lvew/',
        ENABLED: true
    };

    const RATE = 80;
    const PREMIUM_CURRENT_BLOCK = 0.30;
    const PREMIUM_NEXT_BLOCK = 0.20;
    const PREMIUM_EVENING_BLOCK = 0.35;
    const PREMIUM_SATURDAY = 0.30;
    const PREMIUM_RUSH = 0.10;
    const DISCOUNT_FUTURE = 0.15;

    const TIME_WINDOWS = {
        today_am: { label: "Today (8AM-12PM)", start: 8, end: 12 },
        today_pm: { label: "Today (12PM-4PM)", start: 12, end: 16 },
        today_eve: { label: "Today (4PM-8PM)", start: 16, end: 20 },
        tomorrow_am: { label: "Tomorrow (8AM-12PM)", start: 8, end: 12 },
        tomorrow_pm: { label: "Tomorrow (12PM-4PM)", start: 12, end: 16 },
        tomorrow_eve: { label: "Tomorrow (4PM-8PM)", start: 16, end: 20 },
        monday_am: { label: "Monday (8AM-12PM)", start: 8, end: 12 },
        monday_pm: { label: "Monday (12PM-4PM)", start: 12, end: 16 },
        monday_eve: { label: "Monday (4PM-8PM)", start: 16, end: 20 }
    };

    const TASKS = {
        tv_mount: {
            hours: 2.0,
            label: "TV Wall Mount (32–65\")",
            questions: [
                { id: 'tv_size', label: 'What size is your TV?', options: [
                    { value: 'standard', label: '32-65 inches', addon: 0 },
                    { value: 'large', label: 'Larger than 65 inches', addon: 25 }
                ]},
                { id: 'wall_type', label: 'What type of wall?', options: [
                    { value: 'drywall', label: 'Drywall with studs', addon: 0 },
                    { value: 'brick', label: 'Brick/concrete', addon: 40 },
                    { value: 'fireplace', label: 'Above fireplace', addon: 40 }
                ]},
                { id: 'mount_owned', label: 'Do you have the wall mount?', options: [
                    { value: 'yes', label: 'Yes, I have it', addon: 0 },
                    { value: 'no', label: 'No, need to purchase', addon: 0 }
                ]}
            ]
        },
        ceiling_fan: {
            hours: 2.5,
            label: "Ceiling Fan Install/Replace",
            questions: [
                { id: 'replacing', label: 'Replacing existing fan or light?', options: [
                    { value: 'fan', label: 'Yes, existing fan', addon: 0 },
                    { value: 'light', label: 'Yes, existing light fixture', addon: 0 },
                    { value: 'new', label: 'New installation', addon: 0 }
                ]},
                { id: 'fan_box', label: 'Is ceiling box fan-rated?', options: [
                    { value: 'yes', label: 'Yes/Don\'t know', addon: 0 },
                    { value: 'no', label: 'No, needs replacement', addon: 50 }
                ]},
                { id: 'ceiling_height', label: 'Ceiling height?', options: [
                    { value: 'standard', label: 'Under 10 feet', addon: 0 },
                    { value: 'high', label: 'Over 10 feet', addon: 40 }
                ]}
            ]
        },
        light_fixture: {
            hours: 1.5,
            label: "Light Fixture / Chandelier Swap",
            questions: [
                { id: 'fixture_type', label: 'Type of fixture?', options: [
                    { value: 'standard', label: 'Standard light fixture', addon: 0 },
                    { value: 'small_chandelier', label: 'Chandelier (under 25 lbs)', addon: 0 },
                    { value: 'heavy_chandelier', label: 'Heavy chandelier (over 25 lbs)', addon: 40 }
                ]},
                { id: 'ceiling_height', label: 'Ceiling height?', options: [
                    { value: 'standard', label: 'Under 10 feet', addon: 0 },
                    { value: 'high', label: 'Over 10 feet', addon: 30 }
                ]}
            ]
        },
        faucet_showerhead: {
            hours: 1.5,
            label: "Faucet / Showerhead Replace",
            questions: [
                { id: 'fixture_type', label: 'What are you replacing?', options: [
                    { value: 'faucet', label: 'Kitchen/bathroom faucet', addon: 0 },
                    { value: 'showerhead', label: 'Showerhead', addon: 0 },
                    { value: 'both', label: 'Both faucet and showerhead', addon: 0 }
                ]},
                { id: 'plumbing_issues', label: 'Any plumbing issues?', options: [
                    { value: 'none', label: 'No issues', addon: 0 },
                    { value: 'corrosion', label: 'Some corrosion/leaks', addon: 40 },
                    { value: 'access', label: 'Need sink removal', addon: 30 }
                ]}
            ]
        },
        smart_doorbell: {
            hours: 1.25,
            label: "Smart Doorbell Install",
            questions: [
                { id: 'install_type', label: 'Installation type?', options: [
                    { value: 'replace', label: 'Replacing existing doorbell', addon: 0 },
                    { value: 'wireless', label: 'New wireless install', addon: 30 }
                ]},
                { id: 'chime_status', label: 'Current doorbell chime working?', options: [
                    { value: 'working', label: 'Yes, works fine', addon: 0 },
                    { value: 'broken', label: 'No/needs replacement', addon: 40 },
                    { value: 'no_chime', label: 'Don\'t want chime connected', addon: 0 }
                ]}
            ]
        },
        curtains_blinds: {
            hours: 1.5,
            label: "Curtain Rods / Blinds",
            questions: [
                { id: 'quantity', label: 'How many rods/blinds?', options: [
                    { value: 'standard', label: '1-2 items (included)', addon: 0 },
                    { value: 'medium', label: '3-4 items', addon: 40 },
                    { value: 'large', label: '5+ items', addon: 80 }
                ]},
                { id: 'wall_type', label: 'What type of wall?', options: [
                    { value: 'drywall', label: 'Drywall', addon: 0 },
                    { value: 'masonry', label: 'Brick/tile/concrete', addon: 40 }
                ]}
            ]
        },
        floating_shelf: {
            hours: 1.5,
            label: "Floating Shelf Install",
            questions: [
                { id: 'quantity', label: 'How many shelves?', options: [
                    { value: 'standard', label: '1-2 shelves (included)', addon: 0 },
                    { value: 'medium', label: '3-4 shelves', addon: 40 },
                    { value: 'large', label: '5+ items', addon: 80 }
                ]},
                { id: 'weight', label: 'Shelf weight/size?', options: [
                    { value: 'standard', label: 'Standard (under 25 lbs)', addon: 0 },
                    { value: 'heavy', label: 'Heavy-duty (over 25 lbs)', addon: 30 }
                ]}
            ]
        },
        appliance_hookup: {
            hours: 2.0,
            label: "Appliance Hookup (W/D/DW)",
            questions: [
                { id: 'appliance_type', label: 'What appliance?', options: [
                    { value: 'washer', label: 'Washer', addon: 0 },
                    { value: 'dryer', label: 'Dryer', addon: 0 },
                    { value: 'dishwasher', label: 'Dishwasher', addon: 0 },
                    { value: 'multiple', label: 'Multiple appliances', addon: 0 }
                ]},
                { id: 'old_removal', label: 'Replacing an old unit?', options: [
                    { value: 'remove', label: 'Yes, remove old', addon: 40 },
                    { value: 'new', label: 'No, new installation', addon: 0 },
                    { value: 'disconnect', label: 'Just disconnecting old', addon: 0 }
                ]},
                { id: 'hookups_ready', label: 'Are hookups ready?', options: [
                    { value: 'ready', label: 'Yes, all connections ready', addon: 0 },
                    { value: 'new_line', label: 'Need new vent/line', addon: 30 },
                    { value: 'unsure', label: 'Not sure', addon: 0 }
                ]}
            ]
        },
        furniture_assembly: {
            hours: 2.0,
            label: "Furniture Assembly (S–M)",
            questions: [
                { id: 'furniture_type', label: 'What type of furniture?', options: [
                    { value: 'standard', label: 'Dresser/desk/table', addon: 0 },
                    { value: 'bed', label: 'Bed frame', addon: 30 },
                    { value: 'wardrobe', label: 'Large wardrobe', addon: 30 },
                    { value: 'multiple', label: 'Multiple small items', addon: 0 }
                ]},
                { id: 'quantity', label: 'How many items?', options: [
                    { value: 'single', label: '1 major item', addon: 0 },
                    { value: 'few', label: '2-3 small items', addon: 0 },
                    { value: 'many', label: '4+ items', addon: 40 }
                ]}
            ]
        },
        closet_organizer: {
            hours: 2.5,
            label: "Closet Organizer Install",
            questions: [
                { id: 'organizer_type', label: 'Type of organizer?', options: [
                    { value: 'standard', label: 'Shelves and rods', addon: 0 },
                    { value: 'modular', label: 'Modular cube system', addon: 0 },
                    { value: 'wire', label: 'Wire rack system', addon: 0 },
                    { value: 'custom', label: 'Custom wood system', addon: 0 }
                ]},
                { id: 'custom_fitting', label: 'Need custom cutting?', options: [
                    { value: 'no', label: 'No, standard sizes', addon: 0 },
                    { value: 'yes', label: 'Yes, custom fitting', addon: 50 },
                    { value: 'unsure', label: 'Not sure', addon: 0 }
                ]},
                { id: 'wall_type', label: 'What type of wall?', options: [
                    { value: 'drywall', label: 'Standard drywall', addon: 0 },
                    { value: 'masonry', label: 'Concrete/masonry', addon: 40 },
                    { value: 'unsure', label: 'Not sure', addon: 0 }
                ]}
            ]
        },
        general_handyman: {
            hours: 3,
            label: "General Handyman (3+ hours)",
            questions: [
                { id: 'task_complexity', label: 'What type of tasks?', options: [
                    { value: 'basic', label: 'Basic repairs/maintenance', addon: 0 },
                    { value: 'multiple', label: 'Multiple small tasks', addon: 0 },
                    { value: 'complex', label: 'Complex projects', addon: 0 }
                ]},
                { id: 'additional_time', label: 'Need additional time beyond 3 hours?', options: [
                    { value: 'none', label: 'No, 3 hours sufficient', addon: 0 },
                    { value: 'one_block', label: 'Yes, add 3 more hours', addon: 180 },
                    { value: 'two_blocks', label: 'Yes, add 6 more hours', addon: 360 }
                ]},
                { id: 'materials_needed', label: 'Will materials/parts be needed?', options: [
                    { value: 'customer_supplies', label: 'I will provide all', addon: 0 },
                    { value: 'basic_supplies', label: 'May need basic supplies', addon: 0 },
                    { value: 'unsure', label: 'Not sure', addon: 0 }
                ]}
            ]
        }
    };

    // ============================================================================
    // STATE MANAGEMENT
    // ============================================================================
    let formData = {};
    let estimateData = {};
    let selectedPricingOption = null;
    let paymentIntentId = null;
    let paymentElementReady = false;
    let stripe, elements, paymentElement;

    // ============================================================================
    // UTILITY FUNCTIONS
    // ============================================================================
    const isSunday = date => date.getDay() === 0;
    const isSaturday = date => date.getDay() === 6;

    const generateTaskId = () => {
        const timestamp = Date.now().toString(36);
        const random = Math.random().toString(36).substring(2, 8);
        return `TASK-${timestamp}-${random}`.toUpperCase();
    };

    const getCurrentBlock = () => {
        const hour = new Date().getHours();
        if (hour >= 8 && hour < 12) return 'today_am';
        if (hour >= 12 && hour < 16) return 'today_pm';
        if (hour >= 16 && hour < 20) return 'today_eve';
        return null;
    };

    const getAvailableTimeWindows = () => {
        const now = new Date();
        const today = new Date(now);
        const tomorrow = new Date(now);
        tomorrow.setDate(tomorrow.getDate() + 1);

        const currentHour = now.getHours();
        const available = [];

        // Today's windows (excluding Sunday, Saturday only morning)
        if (!isSunday(today)) {
            if (isSaturday(today)) {
                if (currentHour < 12) available.push('today_am');
            } else {
                if (currentHour < 12) available.push('today_am');
                if (currentHour < 16) available.push('today_pm');
                if (currentHour < 20) available.push('today_eve');
            }
        }

        // Tomorrow's windows (excluding Sunday, Saturday only morning)
        if (!isSunday(tomorrow)) {
            if (isSaturday(tomorrow)) {
                available.push('tomorrow_am');
            } else {
                available.push('tomorrow_am', 'tomorrow_pm', 'tomorrow_eve');
            }
        }

        // Monday windows if tomorrow is Sunday
        if (isSaturday(today) && currentHour >= 12 && isSunday(tomorrow)) {
            available.push('monday_am', 'monday_pm', 'monday_eve');
        }

        return available;
    };

    const validatePropertyAddress = address => {
        if (!address || address.trim().length < 10) {
            return { valid: false, message: 'Please enter a complete address (minimum 10 characters)' };
        }

        const hasNumber = /\d+/.test(address);
        if (!hasNumber) {
            return { valid: false, message: 'Address must include a street number' };
        }

        const addressLower = address.toLowerCase();
        const floridaCities = ['boca raton', 'delray beach', 'boynton beach', 'fort lauderdale',
                              'hollywood', 'aventura', 'miami', 'coral gables', 'kendall',
                              'palm beach', 'west palm beach', 'pompano'];
        const hasCity = floridaCities.some(city => addressLower.includes(city));
        const hasZip = /\b33\d{3}\b|\b34\d{3}\b/.test(address);

        if (!hasCity && !hasZip) {
            return { valid: false, message: 'Please include city name or ZIP code (we serve South Florida)' };
        }

        const hasStreetType = /(street|st|avenue|ave|road|rd|drive|dr|lane|ln|boulevard|blvd|way|court|ct|circle|cir|place|pl)/i.test(address);
        if (!hasStreetType) {
            return { valid: false, message: 'Please include street type (St, Ave, Rd, etc.)' };
        }

        return { valid: true };
    };

    // ============================================================================
    // PRICING LOGIC
    // ============================================================================
    function calculatePricing(hours, window, rush, addons = 0, selectedDate = null) {
        const base = hours * RATE;
        const premiums = [];
        let total = base + addons;

        const currentBlock = getCurrentBlock();
        const isToday = window.startsWith('today');
        const isTomorrow = window.startsWith('tomorrow');
        const isMonday = window.startsWith('monday');
        const isFuture = selectedDate !== null && selectedDate !== '';
        const isEveningBlock = window.includes('eve');

        // Determine booking date
        let bookingDate;
        if (isToday) {
            bookingDate = new Date();
        } else if (isTomorrow) {
            bookingDate = new Date();
            bookingDate.setDate(bookingDate.getDate() + 1);
        } else if (isMonday) {
            bookingDate = new Date();
            bookingDate.setDate(bookingDate.getDate() + 2);
        } else if (isFuture && selectedDate) {
            const dateStr = selectedDate.includes('T') ? selectedDate.split('T')[0] : selectedDate;
            bookingDate = new Date(dateStr + 'T12:00:00');
        }

        const isBookingSaturday = bookingDate && isSaturday(bookingDate);

        // Apply pricing rules
        if (isFuture) {
            if (isEveningBlock) {
                const premium = base * PREMIUM_EVENING_BLOCK;
                premiums.push({ label: 'Evening block premium (4-8PM, +35%)', amount: premium });
                total += premium;
            } else if (isBookingSaturday) {
                const satPremium = base * PREMIUM_SATURDAY;
                premiums.push({ label: 'Saturday service premium (+30%)', amount: satPremium });
                total += satPremium;
            } else {
                const discount = base * DISCOUNT_FUTURE;
                premiums.push({ label: 'Future booking discount (-15%)', amount: -discount });
                total -= discount;
            }
        } else if (isToday) {
            if (isBookingSaturday) {
                const satPremium = base * PREMIUM_SATURDAY;
                premiums.push({ label: 'Saturday service premium (+30%)', amount: satPremium });
                total += satPremium;
            }
            if (isEveningBlock) {
                const premium = base * PREMIUM_EVENING_BLOCK;
                premiums.push({ label: 'Evening block premium (4-8PM, +35%)', amount: premium });
                total += premium;
            } else if (window === currentBlock) {
                const premium = base * PREMIUM_CURRENT_BLOCK;
                premiums.push({ label: 'Current time block premium (+30%)', amount: premium });
                total += premium;
            } else {
                const premium = base * PREMIUM_NEXT_BLOCK;
                premiums.push({ label: 'Next available block premium (+20%)', amount: premium });
                total += premium;
            }
        } else if (isTomorrow) {
            if (isBookingSaturday) {
                const satPremium = base * PREMIUM_SATURDAY;
                premiums.push({ label: 'Saturday service premium (+30%)', amount: satPremium });
                total += satPremium;
            }
            if (isEveningBlock) {
                const premium = base * PREMIUM_EVENING_BLOCK;
                premiums.push({ label: 'Evening block premium (4-8PM, +35%)', amount: premium });
                total += premium;
            }
        }

        // Rush service
        if (rush) {
            const premium = base * PREMIUM_RUSH;
            premiums.push({ label: 'Optional rush service (+10%)', amount: premium });
            total += premium;
        }

        // Add-ons
        if (addons > 0) {
            premiums.push({ label: 'Task-specific add-ons', amount: addons });
        }

        return { base, premiums, total, addons };
    }

    function calculateAddons(taskKey) {
        const task = TASKS[taskKey];
        if (!task?.questions) return 0;

        return task.questions.reduce((total, question) => {
            const select = document.getElementById(`question_${question.id}`);
            if (select?.value) {
                const addon = parseInt(select.options[select.selectedIndex].dataset.addon) || 0;
                return total + addon;
            }
            return total;
        }, 0);
    }

    function generatePricingOptions(hours, selectedWindow, rush, addons = 0, selectedDate = null) {
        const options = [];
        const availableWindows = getAvailableTimeWindows();

        // Future date booking
        if (selectedDate) {
            const dateObj = new Date(selectedDate + 'T00:00:00');

            if (isSunday(dateObj)) {
                alert('Sunday bookings are not available. Please select a different date.');
                return [];
            }

            const dayBefore = new Date(dateObj);
            dayBefore.setDate(dayBefore.getDate() - 1);

            let dayAfter = new Date(dateObj);
            dayAfter.setDate(dayAfter.getDate() + 1);
            if (isSunday(dayAfter)) dayAfter.setDate(dayAfter.getDate() + 1);

            const allTimeBlocks = [
                { key: 'morning', label: '8AM-12PM', start: 8, end: 12 },
                { key: 'afternoon', label: '12PM-4PM', start: 12, end: 16 },
                { key: 'evening', label: '4PM-8PM', start: 16, end: 20 }
            ];

            const createOption = (date, block, dateLabel, sectionType, isSat) => {
                const dateString = date.toISOString().split('T')[0];
                const windowIdentifier = block.key === 'evening' ? 'tomorrow_eve' :
                                       block.key === 'afternoon' ? 'tomorrow_pm' : 'tomorrow_am';
                const pricing = calculatePricing(hours, windowIdentifier, rush, addons, dateString);

                let badge = block.key === 'evening' ? 'Evening +35%' :
                           isSat ? 'Saturday +30%' : 'Future -15%';
                let badgeClass = block.key === 'evening' || isSat ? 'premium' : 'discount';

                return {
                    type: 'future',
                    window: `future_${date.getTime()}_${block.key}`,
                    windowLabel: `${dateLabel} (${block.label})`,
                    pricing, badge, badgeClass,
                    selectedDate: dateString,
                    timeBlock: block,
                    sectionType
                };
            };

            // Day before options
            const dayBeforeBlocks = isSaturday(dayBefore) ? [allTimeBlocks[0]] : allTimeBlocks;
            dayBeforeBlocks.forEach(block => {
                options.push(createOption(dayBefore, block,
                    dayBefore.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' }),
                    'Day Before (Better Value)', isSaturday(dayBefore)));
            });

            // Selected date options
            if (!isSaturday(dateObj)) {
                allTimeBlocks.forEach(block => {
                    options.push(createOption(dateObj, block,
                        dateObj.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' }),
                        'Your Selected Date', false));
                });
            } else {
                options.push(createOption(dateObj, allTimeBlocks[0],
                    dateObj.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' }),
                    'Your Selected Date (Saturday)', true));
            }

            // Day after options
            const dayAfterBlocks = isSaturday(dayAfter) ? [allTimeBlocks[0]] : allTimeBlocks;
            dayAfterBlocks.forEach(block => {
                options.push(createOption(dayAfter, block,
                    dayAfter.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' }),
                    'Day After (Better Value)', isSaturday(dayAfter)));
            });

            return options;
        }

        // Flexible window
        if (selectedWindow === 'flexible') {
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);

            let flexibleWindow = 'tomorrow_am';
            let flexibleLabel = 'Tomorrow Morning (8AM-12PM) - Best Value';

            if (isSunday(tomorrow)) {
                flexibleWindow = 'monday_am';
                flexibleLabel = 'Monday Morning (8AM-12PM) - Best Value';
            } else if (isSaturday(tomorrow)) {
                flexibleLabel = 'Tomorrow Morning (8AM-12PM) - Saturday';
            }

            const pricing = calculatePricing(hours, flexibleWindow, rush, addons);
            options.push({
                type: 'flexible',
                window: flexibleWindow,
                windowLabel: flexibleLabel,
                pricing,
                badge: isSaturday(tomorrow) ? 'Saturday' : 'Best Value',
                badgeClass: isSaturday(tomorrow) ? 'premium' : 'discount'
            });

            availableWindows.forEach(window => {
                if (window !== flexibleWindow && !window.includes('today')) {
                    const altPricing = calculatePricing(hours, window, rush, addons);
                    const now = new Date();
                    const windowDate = new Date(now);
                    if (window.startsWith('tomorrow')) windowDate.setDate(windowDate.getDate() + 1);
                    else if (window.startsWith('monday')) windowDate.setDate(windowDate.getDate() + 2);

                    options.push({
                        type: 'alternative',
                        window,
                        windowLabel: TIME_WINDOWS[window].label,
                        pricing: altPricing,
                        badge: isSaturday(windowDate) ? 'Saturday' : 'Good Value',
                        badgeClass: isSaturday(windowDate) ? 'premium' : 'selected'
                    });
                }
            });

            return options;
        }

        // Specific window selection
        availableWindows.forEach(window => {
            const pricing = calculatePricing(hours, window, rush, addons);
            const now = new Date();
            const windowDate = new Date(now);

            if (window.startsWith('tomorrow')) windowDate.setDate(windowDate.getDate() + 1);
            else if (window.startsWith('monday')) windowDate.setDate(windowDate.getDate() + 2);

            const isWindowSaturday = isSaturday(windowDate);
            let badge, badgeClass, type;

            if (window.startsWith('today')) {
                badge = isWindowSaturday ? 'Saturday' : 'Today';
                badgeClass = 'premium';
                type = 'today';
            } else if (window.includes('eve')) {
                badge = 'Evening';
                badgeClass = 'premium';
                type = 'evening';
            } else if (window.startsWith('monday')) {
                badge = 'Monday';
                badgeClass = 'selected';
                type = 'monday';
            } else {
                badge = isWindowSaturday ? 'Saturday' : 'Tomorrow';
                badgeClass = isWindowSaturday ? 'premium' : 'selected';
                type = 'tomorrow';
            }

            if (window === selectedWindow) badge = 'Selected';

            options.push({ type, window, windowLabel: TIME_WINDOWS[window].label, pricing, badge, badgeClass });
        });

        return options;
    }

    // ============================================================================
    // FORM & UI MANAGEMENT
    // ============================================================================
    function showTaskQuestions(taskKey) {
        const task = TASKS[taskKey];
        const questionsSection = document.getElementById('taskQuestions');
        const questionsContainer = document.getElementById('questionsContainer');

        if (!task?.questions?.length) {
            questionsSection.classList.add('hidden');
            return;
        }

        questionsContainer.innerHTML = task.questions.map(question => `
            <div class="space-y-2">
                <label class="block text-sm font-semibold text-slate-700">${question.label}</label>
                <select id="question_${question.id}" class="w-full rounded-lg border border-slate-200 px-3 py-2 text-sm">
                    <option value="">Please select...</option>
                    ${question.options.map(opt =>
                        `<option value="${opt.value}" data-addon="${opt.addon}">${opt.label}${opt.addon > 0 ? ` (+$${opt.addon})` : ''}</option>`
                    ).join('')}
                </select>
            </div>
        `).join('');

        task.questions.forEach(question => {
            document.getElementById(`question_${question.id}`)?.addEventListener('change', () => {
                // Trigger re-calculation if needed
            });
        });

        questionsSection.classList.remove('hidden');
    }

    function saveFormData() {
        formData = {
            name: document.getElementById('customerName').value,
            phone: document.getElementById('customerPhone').value,
            email: document.getElementById('customerEmail').value,
            zip: document.getElementById('customerZip').value,
            address: document.getElementById('customerAddress').value,
            category: document.getElementById('taskCategory').value,
            window: document.getElementById('taskWindow').value,
            futureDate: document.getElementById('futureDate').value || null,
            description: document.getElementById('taskDescription').value,
            rush: document.getElementById('rushOption').checked
        };
        return formData;
    }

    function showEstimateProgress() {
        const btn = document.getElementById('getEstimateBtn');
        const progressBg = document.getElementById('progressBg');
        const text = document.getElementById('estimateText');
        const container = document.getElementById('progressContainer');
        const bar = document.getElementById('progressBar');
        const message = document.getElementById('progressMessage');

        btn.disabled = true;
        container.classList.remove('hidden');

        const steps = [
            { delay: 0, text: '📤 Uploading photos...', msg: 'Uploading photos and analyzing task...', transform: -75, width: 25 },
            { delay: 1500, text: '🤖 AI analyzing...', msg: 'AI is analyzing your photos and requirements...', transform: -40, width: 60 },
            { delay: 3000, text: '💭 Generating options...', msg: 'Creating your pricing options...', transform: -10, width: 90 },
            { delay: 4000, text: '✅ Options ready!', msg: 'Analysis complete! Options generated.', transform: 0, width: 100 }
        ];

        steps.forEach(step => {
            setTimeout(() => {
                text.textContent = step.text;
                message.textContent = step.msg;
                progressBg.style.transform = `translateX(${step.transform}%)`;
                bar.style.width = `${step.width}%`;
            }, step.delay);
        });
    }

    function resetEstimateProgress() {
        setTimeout(() => {
            const btn = document.getElementById('getEstimateBtn');
            const text = document.getElementById('estimateText');
            const container = document.getElementById('progressContainer');
            const progressBg = document.getElementById('progressBg');
            const bar = document.getElementById('progressBar');

            btn.disabled = false;
            text.textContent = '🔧 Get pricing options';
            container.classList.add('hidden');
            progressBg.style.transform = 'translateX(-100%)';
            bar.style.width = '0%';
        }, 1000);
    }

    async function generateEstimate() {
        try {
            const data = saveFormData();

            if (!data.name || !data.phone || !data.email || !data.category) {
                alert('Please fill out all required fields (Name, Phone, Email, and Task)');
                return;
            }

            if (data.futureDate) {
                const selectedDate = new Date(data.futureDate);
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const minDate = new Date(today);
                minDate.setDate(minDate.getDate() + 2);
                const maxDate = new Date(today);
                maxDate.setDate(maxDate.getDate() + 14);

                if (selectedDate < minDate || selectedDate > maxDate) {
                    alert('Please select a date between 2 and 14 days in the future');
                    return;
                }
            }

            showEstimateProgress();

            const hours = TASKS[data.category]?.hours || 1.5;
            const addons = calculateAddons(data.category);

            const response = await fetch('/.netlify/functions/scope', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    category: data.category,
                    description: data.description,
                    base_rate_hr: RATE,
                    hours_base: hours,
                    window: data.window,
                    rush: data.rush,
                    addons,
                    futureDate: data.futureDate,
                    name: data.name,
                    phone: data.phone,
                    email: data.email,
                    address: data.address
                })
            });

            if (!response.ok) throw new Error(`AI estimate failed: ${response.status}`);

            const aiResult = await response.json();
            const pricingOptions = generatePricingOptions(hours, data.window, data.rush, addons, data.futureDate);

            estimateData = { ...aiResult, hours, pricingOptions, futureDate: data.futureDate };

            setTimeout(() => {
                showEstimatePanel(estimateData);
                resetEstimateProgress();
            }, 4500);

        } catch (error) {
            console.error('Generate estimate error:', error);
            alert('Failed to generate estimate: ' + error.message);
            resetEstimateProgress();
        }
    }

    function showEstimatePanel(estimate) {
        const isFlexible = formData.window === 'flexible';
        const hasFutureDate = formData.futureDate !== null && formData.futureDate !== '';

        const flexibleNotice = document.getElementById('flexibleNotice');
        const optionsContainer = document.getElementById('pricingOptions');

        if (flexibleNotice) {
            flexibleNotice.classList.toggle('hidden', !isFlexible);
        }

        optionsContainer.innerHTML = '';

        const hasSections = estimate.pricingOptions.some(opt => opt.sectionType);

        if (hasSections) {
            const sections = {};
            estimate.pricingOptions.forEach(option => {
                const sectionName = option.sectionType || 'Other';
                if (!sections[sectionName]) sections[sectionName] = [];
                sections[sectionName].push(option);
            });

            const sectionOrder = ['Day Before (Better Value)', 'Your Selected Date', 'Your Selected Date (Saturday)', 'Day After (Better Value)'];

            sectionOrder.forEach(sectionName => {
                if (sections[sectionName]) {
                    if (optionsContainer.children.length > 0) {
                        const divider = document.createElement('div');
                        divider.className = 'section-divider';
                        optionsContainer.appendChild(divider);
                    }

                    const sectionHeader = document.createElement('div');
                    sectionHeader.className = 'section-header-wrapper';

                    let headerClass = 'text-base font-bold';
                    let icon = '';
                    let description = '';

                    if (sectionName.includes('Better Value')) {
                        headerClass += ' text-green-700';
                        icon = '💰 ';
                        description = '<span class="text-xs font-normal text-green-600 ml-2">(Save money with these options)</span>';
                    } else if (sectionName.includes('Saturday')) {
                        headerClass += ' text-orange-700';
                        icon = '📅 ';
                        description = '<span class="text-xs font-normal text-orange-600 ml-2">(Premium pricing applies)</span>';
                    } else {
                        headerClass += ' text-indigo-700';
                        icon = '📌 ';
                    }

                    sectionHeader.innerHTML = `<div class="${headerClass}">${icon}${sectionName}${description}</div>`;
                    optionsContainer.appendChild(sectionHeader);

                    sections[sectionName].forEach((option, index) => {
                        const optionCard = createPricingOptionCard(option, estimate.hours, index === 0 && sectionName === 'Your Selected Date');
                        optionsContainer.appendChild(optionCard);
                    });
                }
            });
        } else {
            estimate.pricingOptions.forEach((option, index) => {
                const optionCard = createPricingOptionCard(option, estimate.hours, index === 0);
                optionsContainer.appendChild(optionCard);
            });
        }

        document.getElementById('estimateScope').innerHTML = (estimate.step_scope || []).map(s => `<li>${s}</li>`).join('');
        document.getElementById('estimateRisks').innerHTML = (estimate.risk_flags || []).map(r => `<li>${r}</li>`).join('');
        document.getElementById('estimatePanel').classList.remove('hidden');
        document.getElementById('estimatePanel').scrollIntoView({ behavior: 'smooth', block: 'start' });
    }

    function createPricingOptionCard(option, hours, autoSelect) {
        const optionCard = document.createElement('div');
        optionCard.className = 'pricing-option relative border-2 border-slate-200 rounded-xl p-4 cursor-pointer';
        optionCard.dataset.optionType = option.type;
        optionCard.dataset.window = option.window;

        let breakdownHTML = '';
        if (option.pricing.premiums?.length) {
            breakdownHTML = '<div class="text-xs text-slate-500 mt-2">';
            option.pricing.premiums.forEach(premium => {
                const sign = premium.amount >= 0 ? '+' : '';
                breakdownHTML += `<div>${premium.label}: ${sign}${Math.abs(premium.amount).toFixed(0)}</div>`;
            });
            breakdownHTML += '</div>';
        }

        optionCard.innerHTML = `
            <div class="pricing-badge ${option.badgeClass}">${option.badge}</div>
            <div class="flex items-center justify-between">
                <div>
                    <div class="font-semibold text-lg">${option.windowLabel}</div>
                    <div class="text-sm text-slate-600">${hours.toFixed(1)} hours estimated</div>
                </div>
                <div class="text-right">
                    <div class="text-2xl font-bold">$${option.pricing.total.toFixed(0)}</div>
                </div>
            </div>
            ${breakdownHTML}
        `;

        optionCard.addEventListener('click', () => selectPricingOption(option, optionCard));

        if (autoSelect) {
            setTimeout(() => selectPricingOption(option, optionCard), 100);
        }

        return optionCard;
    }

    function selectPricingOption(option, cardElement) {
        document.querySelectorAll('.pricing-option').forEach(card => card.classList.remove('selected'));
        cardElement.classList.add('selected');

        selectedPricingOption = {
            ...option,
            window: option.window,
            windowLabel: option.windowLabel,
            type: option.type,
            pricing: { ...option.pricing }
        };

        document.getElementById('reserveBtn').disabled = false;
    }

    // ============================================================================
    // PAYMENT PROCESSING
    // ============================================================================
    function initializeStripe() {
        if (typeof Stripe !== 'undefined') {
            try {
                stripe = Stripe(STRIPE_PUBLISHABLE_KEY);
            } catch (error) {
                console.error('Stripe initialization failed:', error);
            }
        } else {
            setTimeout(initializeStripe, 1000);
        }
    }

    async function showPaymentModal() {
        if (!selectedPricingOption) {
            alert('Please select a pricing option first');
            return;
        }

        if (!stripe) {
            alert('Payment system is still loading. Please try again in a moment.');
            return;
        }

        const finalAmount = selectedPricingOption.pricing.total;

        document.getElementById('paymentAmount').textContent = '$' + finalAmount.toFixed(0);
        document.getElementById('paymentTiming').textContent = selectedPricingOption.windowLabel;
        document.getElementById('paymentModal').classList.remove('hidden');

        paymentElementReady = false;

        const paymentMessage = document.getElementById('paymentMessage');
        paymentMessage.classList.add('hidden');
        paymentMessage.textContent = '';

        try {
            const response = await fetch('/.netlify/functions/create-payment', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    amount: finalAmount,
                    currency: 'usd',
                    customer_info: {
                        name: formData.name,
                        email: formData.email,
                        phone: formData.phone
                    },
                    job_details: {
                        category: formData.category,
                        window: selectedPricingOption.window,
                        hours: estimateData.hours,
                        selected_option_type: selectedPricingOption.type,
                        futureDate: formData.futureDate
                    }
                })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `Payment setup failed: ${response.status}`);
            }

            const result = await response.json();

            if (!result.client_secret) {
                throw new Error('No client secret received from server');
            }

            paymentIntentId = result.payment_intent_id;

            // Clean up previous elements
            if (paymentElement) {
                try { paymentElement.unmount(); } catch (e) {}
                paymentElement = null;
            }
            if (elements) {
                elements = null;
            }

            elements = stripe.elements({
                clientSecret: result.client_secret,
                appearance: {
                    theme: 'stripe',
                    variables: { colorPrimary: '#4f46e5' }
                }
            });

            paymentElement = elements.create('payment', {
                layout: { type: 'tabs', defaultCollapsed: false }
            });

            const mountTarget = document.getElementById('stripe-payment-element');
            if (!mountTarget) throw new Error('Payment element container not found');

            mountTarget.innerHTML = '';

            await new Promise((resolve, reject) => {
                let readyFired = false;

                paymentElement.mount('#stripe-payment-element');

                paymentElement.on('ready', () => {
                    paymentElementReady = true;
                    readyFired = true;
                    resolve();
                });

                paymentElement.on('loaderror', (error) => {
                    reject(new Error(error.error?.message || 'Failed to load payment form'));
                });

                setTimeout(() => {
                    if (!readyFired) {
                        const elementInDom = document.querySelector('#stripe-payment-element iframe');
                        if (elementInDom) {
                            paymentElementReady = true;
                            resolve();
                        } else {
                            reject(new Error('Payment element failed to mount'));
                        }
                    }
                }, 8000);
            });

        } catch (error) {
            console.error('Payment setup error:', error);
            paymentMessage.textContent = 'Unable to load payment form. Please try again or contact support.';
            paymentMessage.classList.remove('hidden');
            paymentMessage.className = 'mt-4 text-sm text-red-600 p-3 bg-red-50 rounded-lg';

            setTimeout(() => {
                document.getElementById('paymentModal').classList.add('hidden');
            }, 3000);
        }
    }

    async function processPayment(event) {
        event.preventDefault();

        const submitBtn = document.getElementById('submitPayment');
        const btnText = document.getElementById('paymentButtonText');
        const paymentMessage = document.getElementById('paymentMessage');

        if (!stripe || !elements || !paymentElement || !paymentElementReady) {
            alert('Payment form not ready. Please wait a moment and try again.');
            return;
        }

        const elementInDom = document.querySelector('#stripe-payment-element iframe');
        if (!elementInDom) {
            alert('Payment form not properly loaded. Please close and reopen the payment window.');
            return;
        }

        if (!selectedPricingOption) {
            alert('No pricing option selected. Please go back and select an option.');
            return;
        }

        submitBtn.disabled = true;
        btnText.textContent = 'Processing payment...';
        paymentMessage.classList.add('hidden');

        try {
            const { error: submitError } = await elements.submit();
            if (submitError) throw new Error(submitError.message);

            const { error, paymentIntent } = await stripe.confirmPayment({
                elements,
                confirmParams: {
                    return_url: `${window.location.origin}${window.location.pathname}#success`,
                    payment_method_data: {
                        billing_details: {
                            name: formData.name,
                            email: formData.email,
                            phone: formData.phone,
                            address: { postal_code: formData.zip }
                        }
                    }
                },
                redirect: 'if_required'
            });

            if (error) throw new Error(error.message);

            if (paymentIntent?.status === 'succeeded') {
                paymentIntentId = paymentIntent.id;
                document.getElementById('paymentModal').classList.add('hidden');
                showTaskInfoModal();
            } else if (paymentIntent?.status === 'requires_action') {
                btnText.textContent = 'Authenticating...';
            } else {
                throw new Error('Payment was not completed successfully');
            }

        } catch (error) {
            console.error('Payment failed:', error);

            let userMessage = 'Payment failed. Please try again.';
            if (error.message.includes('incomplete')) userMessage = 'Please complete all payment details.';
            else if (error.message.includes('card_declined')) userMessage = 'Your card was declined. Please try a different card.';
            else if (error.message.includes('insufficient_funds')) userMessage = 'Insufficient funds. Please try a different card.';
            else if (error.message.includes('expired_card')) userMessage = 'Your card has expired. Please try a different card.';
            else if (error.message.includes('incorrect_cvc')) userMessage = 'Incorrect CVC code. Please check and try again.';
            else if (error.message.includes('processing_error')) userMessage = 'Processing error. Please try again in a moment.';
            else if (error.message) userMessage = error.message;

            paymentMessage.textContent = userMessage;
            paymentMessage.classList.remove('hidden');
            paymentMessage.className = 'mt-4 text-sm text-red-600 p-3 bg-red-50 rounded-lg border border-red-200';

            submitBtn.disabled = false;
            btnText.textContent = 'Complete Payment';
        }
    }

    // ============================================================================
    // NOTIFICATIONS
    // ============================================================================
    async function sendSMSNotification(type, data) {
        try {
            const response = await fetch('/.netlify/functions/send-sms', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ type, data })
            });

            if (response.ok) {
                const result = await response.json();
                return { success: true, data: result };
            } else {
                const error = await response.json();
                return { success: false, error: error.error };
            }
        } catch (error) {
            return { success: false, error: error.message };
        }
    }

    async function sendZapierNotification(jobData) {
        if (!ZAPIER_CONFIG.ENABLED || ZAPIER_CONFIG.WEBHOOK_URL.includes('YOUR_ZAPIER_WEBHOOK_ID')) {
            return { success: false, message: 'Webhook not configured' };
        }

        const zapierData = {
            task_id: jobData.task_id,
            timestamp: new Date().toISOString(),
            customer_name: jobData.name,
            customer_phone: jobData.phone,
            customer_email: jobData.email,
            customer_zip: jobData.zip,
            customer_address: jobData.address || '',
            task_category: jobData.category,
            task_category_label: TASKS[jobData.category]?.label || jobData.category,
            time_window: jobData.window,
            description: jobData.description || 'None provided',
            rush_service: jobData.rush,
            estimated_hours: jobData.estimated_hours,
            base_amount: jobData.base_amount,
            total_amount: jobData.total_amount,
            total_amount_formatted: '$' + jobData.total_amount.toFixed(2),
            premiums_applied: jobData.premiums?.map(p => p.label).join(', ') || 'None',
            property_address: jobData.property_address,
            contact_phone: jobData.contact_phone,
            access_details: jobData.access_details || 'None provided',
            pets_and_special: jobData.pets_and_special || 'None provided',
            additional_details: jobData.additional_details || 'None provided',
            payment_intent_id: jobData.payment_intent_id,
            step_scope: jobData.step_scope?.join(' • ') || 'Standard scope',
            risk_flags: jobData.risk_flags?.join(' • ') || 'No special risks noted',
            notification_email: 'info@sendahandyman.com'
        };

        try {
            const params = new URLSearchParams();
            Object.keys(zapierData).forEach(key => params.append(key, zapierData[key]));

            const response = await fetch(ZAPIER_CONFIG.WEBHOOK_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: params.toString()
            });

            if (response.ok) {
                const result = await response.json();
                return { success: true, data: result };
            } else {
                throw new Error(`Zapier webhook failed: ${response.status} ${response.statusText}`);
            }
        } catch (error) {
            console.error('Zapier notification failed:', error);
            return { success: false, error: error.message };
        }
    }

    // ============================================================================
    // TASK INFO & FINAL SUBMISSION
    // ============================================================================
    function showTaskInfoModal() {
        const taskId = generateTaskId();
        window.currentTaskId = taskId;
        const paidAmount = selectedPricingOption.pricing.total;

        document.getElementById('summaryTaskId').textContent = taskId;
        document.getElementById('summaryName').textContent = formData.name;
        document.getElementById('summaryPhone').textContent = formData.phone;
        document.getElementById('summaryEmail').textContent = formData.email;
        document.getElementById('summaryTask').textContent = TASKS[formData.category]?.label || formData.category;
        document.getElementById('summaryWindow').textContent = selectedPricingOption.windowLabel;
        document.getElementById('summaryDescription').textContent = formData.description || 'None provided';
        document.getElementById('summaryAmount').textContent = '$' + paidAmount.toFixed(2);
        document.getElementById('contactPhone').value = formData.phone;
        document.getElementById('taskInfoModal').classList.remove('hidden');
    }

    async function submitTaskInfo(event) {
        event.preventDefault();

        const propertyAddress = document.getElementById('propertyAddress').value;
        const addressValidation = validatePropertyAddress(propertyAddress);

        if (!addressValidation.valid) {
            alert('Address Error: ' + addressValidation.message);
            document.getElementById('propertyAddress').focus();
            return;
        }

        const submitBtn = event.target.querySelector('button[type="submit"]');
        submitBtn.disabled = true;
        submitBtn.textContent = '📤 Sending notification...';

        const taskId = window.currentTaskId;
        const currentFormData = saveFormData();

        if (!currentFormData.name || !currentFormData.phone || !currentFormData.email || !currentFormData.category) {
            alert('Critical form data is missing. Please refresh and try again.');
            submitBtn.disabled = false;
            submitBtn.textContent = '🚀 Dispatch Handyman';
            return;
        }

        const completeJobData = {
            task_id: taskId,
            payment_intent_id: paymentIntentId,
            category: currentFormData.category,
            window: selectedPricingOption.window,
            name: currentFormData.name,
            phone: currentFormData.phone,
            email: currentFormData.email,
            zip: currentFormData.zip,
            address: currentFormData.address || '',
            description: currentFormData.description || '',
            rush: currentFormData.rush || false,
            property_address: propertyAddress,
            contact_phone: document.getElementById('contactPhone').value,
            access_details: document.getElementById('accessDetails').value || '',
            pets_and_special: document.getElementById('petsAndSpecial').value || '',
            additional_details: document.getElementById('additionalDetails').value || '',
            estimated_hours: estimateData.hours,
            total_amount: selectedPricingOption.pricing.total,
            base_amount: selectedPricingOption.pricing.base,
            premiums: selectedPricingOption.pricing.premiums || [],
            step_scope: estimateData.step_scope || [],
            risk_flags: estimateData.risk_flags || []
        };

        // Send notifications (don't block on failures)
        try {
            await sendSMSNotification('booking_confirmation', {
                customer_phone: completeJobData.phone,
                task_id: taskId,
                service_name: TASKS[completeJobData.category]?.label,
                time_window: TIME_WINDOWS[completeJobData.window]?.label || completeJobData.window,
                total_amount: selectedPricingOption.pricing.total.toFixed(0)
            });
        } catch (e) {}

        try {
            await sendZapierNotification(completeJobData);
        } catch (e) {}

        try {
            await fetch('/.netlify/functions/send-notification', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(completeJobData)
            });
        } catch (e) {}

        document.getElementById('finalTaskId').textContent = taskId;
        document.getElementById('finalPaidAmount').textContent = '$' + selectedPricingOption.pricing.total.toFixed(2);
        document.getElementById('taskInfoModal').classList.add('hidden');
        document.getElementById('finalSuccessModal').classList.remove('hidden');
    }

    // ============================================================================
    // MOBILE MENU
    // ============================================================================
    function initializeMobileMenu() {
        const mobileMenuBtn = document.getElementById('mobile-menu-btn');
        const mobileMenu = document.getElementById('mobile-menu');

        mobileMenuBtn.addEventListener('click', () => {
            mobileMenu.classList.toggle('active');
        });

        document.querySelectorAll('#mobile-menu a').forEach(link => {
            link.addEventListener('click', () => {
                mobileMenu.classList.remove('active');
            });
        });

        document.addEventListener('click', (e) => {
            if (!mobileMenuBtn.contains(e.target) && !mobileMenu.contains(e.target)) {
                mobileMenu.classList.remove('active');
            }
        });
    }

    // ============================================================================
    // CHATBOT
    // ============================================================================
    function initializeChatbot() {
        const chatToggle = document.getElementById('chatbot-toggle');
        const chatWindow = document.getElementById('chatbot-window');
        const chatClose = document.getElementById('chatbot-close');
        const chatInput = document.getElementById('chatbot-input');
        const chatSend = document.getElementById('chatbot-send');
        const chatMessages = document.getElementById('chatbot-messages');

        let conversationHistory = [];
        let isOpen = false;

        chatToggle.addEventListener('click', () => {
            isOpen = !isOpen;
            chatWindow.classList.toggle('hidden', !isOpen);
            if (isOpen) chatInput.focus();
        });

        chatClose.addEventListener('click', () => {
            isOpen = false;
            chatWindow.classList.add('hidden');
        });

        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        chatSend.addEventListener('click', sendMessage);

        async function sendMessage() {
            const message = chatInput.value.trim();
            if (!message) return;

            addMessage(message, 'user');
            chatInput.value = '';

            const typingIndicator = addTypingIndicator();

            try {
                const response = await fetch('/.netlify/functions/chatbot', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message, conversationHistory })
                });

                typingIndicator.remove();

                if (!response.ok) throw new Error('Network response was not ok');

                const result = await response.json();

                if (result.error) {
                    addMessage(result.error, 'bot', true);
                } else {
                    addMessage(result.reply, 'bot');
                }

                conversationHistory.push(
                    { role: 'human', content: message },
                    { role: 'assistant', content: result.reply || 'Error occurred' }
                );

                if (conversationHistory.length > 20) {
                    conversationHistory = conversationHistory.slice(-20);
                }

            } catch (error) {
                typingIndicator.remove();
                addMessage('Sorry, I\'m having trouble connecting right now. Please try again or contact us directly at info@sendahandyman.com', 'bot', true);
            }
        }

        function addMessage(content, sender, isError = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'flex items-start space-x-2';

            if (sender === 'user') {
                messageDiv.innerHTML = `
                    <div class="flex-1"></div>
                    <div class="bg-indigo-600 text-white rounded-lg p-3 max-w-xs">
                        <p class="text-sm">${escapeHtml(content)}</p>
                    </div>
                    <div class="w-8 h-8 rounded-full bg-indigo-600 flex items-center justify-center flex-shrink-0">
                        <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
                        </svg>
                    </div>
                `;
            } else {
                messageDiv.innerHTML = `
                    <div class="w-8 h-8 rounded-full bg-indigo-100 flex items-center justify-center flex-shrink-0">
                        <svg class="w-4 h-4 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path>
                        </svg>
                    </div>
                    <div class="bg-slate-100 rounded-lg p-3 max-w-xs ${isError ? 'border border-red-200 bg-red-50' : ''}">
                        <p class="text-sm text-slate-700">${formatBotMessage(content)}</p>
                    </div>
                `;
            }

            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function addTypingIndicator() {
            const typingDiv = document.createElement('div');
            typingDiv.className = 'flex items-start space-x-2';
            typingDiv.innerHTML = `
                <div class="w-8 h-8 rounded-full bg-indigo-100 flex items-center justify-center flex-shrink-0">
                    <svg class="w-4 h-4 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path>
                    </svg>
                </div>
                <div class="bg-slate-100 rounded-lg p-3">
                    <p class="text-sm text-slate-500 chatbot-typing">Typing</p>
                </div>
            `;

            chatMessages.appendChild(typingDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            return typingDiv;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatBotMessage(content) {
            return escapeHtml(content)
                .replace(/\n/g, '<br>')
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>');
        }
    }

    // ============================================================================
    // INITIALIZATION
    // ============================================================================
    document.addEventListener('DOMContentLoaded', () => {
        // Populate time windows
        function populateTimeWindows() {
            const select = document.getElementById('taskWindow');
            if (!select) return;

            const availableWindows = getAvailableTimeWindows();
            select.innerHTML = '<option value="flexible">I\'m flexible (best value)</option>';

            const separator = document.createElement('option');
            separator.disabled = true;
            separator.textContent = '──────────────────';
            select.appendChild(separator);

            availableWindows.forEach(windowKey => {
                const option = document.createElement('option');
                option.value = windowKey;
                option.textContent = TIME_WINDOWS[windowKey].label;
                select.appendChild(option);
            });
        }

        populateTimeWindows();
        setInterval(populateTimeWindows, 60000);

        // Setup date picker
        function setupDatePicker() {
            const dateInput = document.getElementById('futureDate');
            if (!dateInput) return;

            const today = new Date();
            const minDate = new Date(today);
            minDate.setDate(minDate.getDate() + 2);
            const maxDate = new Date(today);
            maxDate.setDate(maxDate.getDate() + 14);

            dateInput.min = minDate.toISOString().split('T')[0];
            dateInput.max = maxDate.toISOString().split('T')[0];

            let warningDiv = document.getElementById('datePickerWarning');
            if (!warningDiv) {
                warningDiv = document.createElement('div');
                warningDiv.id = 'datePickerWarning';
                warningDiv.className = 'hidden mt-2 p-2 bg-red-50 border border-red-200 rounded-lg text-xs text-red-700 date-warning';
                dateInput.parentNode.appendChild(warningDiv);
            }

            const validateDate = (e) => {
                if (!e.target.value) {
                    warningDiv.classList.add('hidden');
                    dateInput.classList.remove('has-sunday-warning');
                    return;
                }

                const selectedDate = new Date(e.target.value + 'T00:00:00');

                if (isSunday(selectedDate)) {
                    warningDiv.textContent = '🚫 SUNDAYS ARE NOT AVAILABLE - Please select Monday-Saturday';
                    warningDiv.classList.remove('hidden');
                    dateInput.classList.add('has-sunday-warning');
                    e.target.value = '';

                    setTimeout(() => {
                        alert('🚫 SUNDAYS NOT AVAILABLE\n\nWe do not offer service on Sundays. Please select Monday-Saturday.');
                    }, 100);
                    return;
                }

                warningDiv.classList.add('hidden');
                dateInput.classList.remove('has-sunday-warning');

                if (isSaturday(selectedDate)) {
                    warningDiv.textContent = '📅 SATURDAY: Only 8AM-12PM available • 30% premium (no discount)';
                    warningDiv.classList.remove('hidden');
                    warningDiv.className = 'mt-2 p-2 bg-orange-50 border border-orange-200 rounded-lg text-xs text-orange-700 date-warning';

                    setTimeout(() => {
                        alert('📅 SATURDAY BOOKING NOTICE\n\n• Only 8AM-12PM time slot available\n• 30% Saturday premium applies\n• NO 15% future booking discount\n\nNet result: +30% premium for Saturday service');
                    }, 100);
                } else {
                    warningDiv.className = 'hidden mt-2 p-2 bg-red-50 border border-red-200 rounded-lg text-xs text-red-700 date-warning';
                }
            };

            dateInput.addEventListener('change', validateDate);
            dateInput.addEventListener('input', validateDate);
        }

        setupDatePicker();

        // Initialize Stripe
        initializeStripe();

        // Initialize mobile menu
        initializeMobileMenu();

        // Service cards
        document.querySelectorAll('.service-card').forEach(card => {
            const header = card.querySelector('.service-header');
            if (!header) return;

            header.addEventListener('click', (e) => {
                e.stopPropagation();
                const taskKey = card.getAttribute('data-task');
                const details = card.querySelector('.service-details');
                const icon = card.querySelector('.expand-icon');

                document.querySelectorAll('.service-card').forEach(otherCard => {
                    if (otherCard !== card) {
                        const otherDetails = otherCard.querySelector('.service-details');
                        const otherIcon = otherCard.querySelector('.expand-icon');
                        if (otherDetails) otherDetails.classList.add('hidden');
                        if (otherIcon) otherIcon.style.transform = 'rotate(0deg)';
                    }
                });

                if (details && icon) {
                    if (details.classList.contains('hidden')) {
                        details.classList.remove('hidden');
                        icon.style.transform = 'rotate(180deg)';

                        const taskDropdown = document.getElementById('taskCategory');
                        if (taskDropdown) taskDropdown.value = taskKey;

                        showTaskQuestions(taskKey);

                        setTimeout(() => {
                            document.getElementById('book')?.scrollIntoView({ behavior: 'smooth' });
                        }, 300);
                    } else {
                        details.classList.add('hidden');
                        icon.style.transform = 'rotate(0deg)';
                    }
                }
            });
        });

        // Task category dropdown
        const taskCategoryDropdown = document.getElementById('taskCategory');
        if (taskCategoryDropdown) {
            taskCategoryDropdown.addEventListener('change', (e) => {
                const taskKey = e.target.value;
                if (taskKey) {
                    showTaskQuestions(taskKey);
                } else {
                    document.getElementById('taskQuestions').classList.add('hidden');
                }
            });
        }

        // Photo upload
        const photoInput = document.getElementById('taskPhotos');
        if (photoInput) {
            photoInput.addEventListener('change', (e) => {
                const thumbs = document.getElementById('photoThumbs');
                if (thumbs) {
                    thumbs.innerHTML = '';
                    [...e.target.files].slice(0, 5).forEach(file => {
                        const url = URL.createObjectURL(file);
                        const img = document.createElement('img');
                        img.src = url;
                        img.className = 'h-16 w-16 object-cover rounded-lg border';
                        thumbs.appendChild(img);
                    });
                }
            });
        }

        // Get estimate button
        document.getElementById('getEstimateBtn')?.addEventListener('click', generateEstimate);

        // Reserve button
        document.getElementById('reserveBtn')?.addEventListener('click', showPaymentModal);

        // Payment form
        document.getElementById('paymentForm')?.addEventListener('submit', processPayment);

        // Close payment modal
        document.getElementById('closePayment')?.addEventListener('click', () => {
            if (paymentElement) {
                try { paymentElement.unmount(); } catch (e) {}
                paymentElement = null;
            }
            if (elements) elements = null;
            paymentElementReady = false;
            document.getElementById('paymentModal').classList.add('hidden');
        });

        // Task info form
        document.getElementById('taskInfoForm')?.addEventListener('submit', submitTaskInfo);

        // Close final success modal
        document.getElementById('closeFinalSuccess')?.addEventListener('click', () => {
            document.getElementById('finalSuccessModal').classList.add('hidden');
            location.reload();
        });

        // Footer
        document.getElementById('year').textContent = new Date().getFullYear();
        document.getElementById('version').textContent = APP_VERSION;

        // Initialize chatbot
        initializeChatbot();
    });
</script>