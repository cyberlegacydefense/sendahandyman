// netlify/functions/send-notification.js
export const handler = async (event, context) => {
  try {
    if (event.httpMethod === "OPTIONS") {
      return { statusCode: 200, headers: cors() };
    }
    if (event.httpMethod !== "POST") {
      return { statusCode: 405, headers: cors(), body: JSON.stringify({ error: "Method not allowed" }) };
    }

    const jobData = JSON.parse(event.body || "{}");

    // Create formatted email content
    const emailContent = createEmailContent(jobData);

    // Send email using a simple email service
    // For MVP, we'll use a webhook to Zapier or similar service
    // You can replace this with SendGrid, Mailgun, etc.

    try {
      // Option 1: Use Zapier webhook (replace with your webhook URL)
      const zapierWebhookUrl = process.env.ZAPIER_WEBHOOK_URL;

      if (zapierWebhookUrl) {
        await fetch(zapierWebhookUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            to: 'frizzo@gmail.com',
            subject: `üîß NEW JOB: ${jobData.task.category} - ${jobData.customer.name}`,
            message: emailContent,
            payment_amount: `$${jobData.amount}`,
            payment_id: jobData.payment_intent_id
          })
        });
      }

      // Option 2: Log to function logs (you can check these manually)
      console.log("=== NEW JOB NOTIFICATION ===");
      console.log(emailContent);
      console.log("================================");

      return {
        statusCode: 200,
        headers: cors(),
        body: JSON.stringify({ success: true, message: "Notification sent" })
      };

    } catch (emailError) {
      console.error('Email sending failed:', emailError);
      // Still log the job details even if email fails
      console.log("=== FAILED EMAIL - JOB DETAILS ===");
      console.log(emailContent);
      console.log("===================================");

      return {
        statusCode: 200,
        headers: cors(),
        body: JSON.stringify({ success: true, message: "Job logged" })
      };
    }

  } catch (error) {
    console.error('Notification function error:', error);
    return {
      statusCode: 500,
      headers: cors(),
      body: JSON.stringify({ error: 'Notification failed', detail: error.message })
    };
  }
};

function createEmailContent(jobData) {
  const { customer, task, estimate, amount, payment_intent_id } = jobData;

  return `
üîß NEW HANDYMAN JOB REQUEST

üí∞ PAYMENT CONFIRMED: $${amount} (${payment_intent_id})

üë§ CUSTOMER INFO:
Name: ${customer.name}
Phone: ${customer.phone}
Email: ${customer.email}
Address: ${customer.address}

üìã JOB DETAILS:
Task: ${task.category}
Window: ${task.window}
Description: ${task.description}
Additional Details: ${task.task_details || 'None'}
Special Instructions: ${task.special_instructions || 'None'}

üîç AI SCOPE FOR CUSTOMER:
${(estimate?.step_scope || []).map(step => `‚Ä¢ ${step}`).join('\n')}

‚ö†Ô∏è CUSTOMER RISK FLAGS:
${(estimate?.risk_flags || []).map(flag => `‚Ä¢ ${flag}`).join('\n')}

üõ†Ô∏è HANDYMAN TECHNICAL INSTRUCTIONS:
${(estimate?.handyman_data?.scope || []).map(step => `‚Ä¢ ${step}`).join('\n')}

‚ö†Ô∏è TECHNICAL RISK FLAGS:
${(estimate?.handyman_data?.risks || []).map(risk => `‚Ä¢ ${risk}`).join('\n')}

üß∞ TOOLS & PARTS TO BRING:
${(estimate?.handyman_data?.tools || []).map(tool => `‚Ä¢ ${tool}`).join('\n')}

‚è±Ô∏è ESTIMATED DURATION: ${estimate?.estimated_duration_hours || 'Unknown'} hours

---
Generated by SendAHandyman AI
Time: ${new Date().toLocaleString()}
  `.trim();
}

function cors() {
  return {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "POST, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type, Authorization"
  };
}